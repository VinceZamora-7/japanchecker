<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>InstaFont</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        max-width: 900px;
        margin: 20px auto;
        padding: 24px 30px;
        background: #f5f7fa;
        color: #2c3e50;
        line-height: 1.6;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 30px;
        text-align: center;
        color: #34495e;
      }

      label {
        font-weight: 600;
        margin-bottom: 0.5em;
        display: block;
        font-size: 1.125em;
        color: #34495e;
      }

      .note {
        font-size: 0.9em;
        color: #666;
        margin-top: 10px;
        margin-bottom: 10px;
        font-style: italic;
      }

      .font-size-container {
        background: #fff;
        padding: 20px 25px 30px;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgb(0 0 0 / 0.08);
        margin-bottom: 30px;
      }

      input[type="number"],
      select {
        font-size: 1rem;
        padding: 8px 14px;
        margin-right: 20px;
        border-radius: 8px;
        border: 1.8px solid #bdc3c7;
        box-shadow: inset 0 2px 6px #e2e6ec;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        min-width: 130px;
        outline-offset: 2px;
        cursor: pointer;
        font-family: inherit;
      }

      input[type="number"]:focus,
      select:focus {
        border-color: #3498db;
        box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
        outline: none;
      }

      textarea {
        width: 100%;
        font-family: "Yu Gothic UI", "Segoe UI", sans-serif;
        font-size: 1rem;
        resize: vertical;
        min-height: 140px;
        padding: 16px 18px;
        border-radius: 12px;
        border: 1.8px solid #bdc3c7;
        box-shadow: inset 0 4px 10px #dfe4eb;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
      }

      button {
        display: inline-block;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 1.1em;
        font-weight: 600;
        padding: 14px 28px;
        cursor: pointer;
        margin: 25px 12px 35px 0;
        box-shadow: 0 5px 15px rgba(52, 152, 219, 0.35);
      }

      button:hover {
        background-color: #2c80cc;
      }

      #btnCopy {
        background-color: #27ae60;
      }

      #btnCopy:hover {
        background-color: #1e8449;
      }

      .output-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 20px;
        margin-bottom: 30px;
      }

      #output,
      #nonEnglishOutput {
        min-width: 0;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-word;
        padding: 20px 24px;
        border-radius: 12px;
        font-family: "Courier New", Courier, monospace;
        font-size: 1rem;
      }

      .output-label {
        display: block;
        font-weight: 700;
        font-size: 1.1rem;
        color: #34495e;
        margin-bottom: 8px;
      }

      #output {
        background: #272822;
        color: #f8f8f2;
        box-shadow: inset 0 0 16px #222;
      }

      #nonEnglishOutput {
        background: #eaf4fc;
        color: #1a3d7c;
        box-shadow: inset 0 0 8px #cbe0fc;
        position: relative; /* for tooltip positioning */
      }

      .highlight-nonenglish {
        background-color: #a9d1ff;
        color: #003366;
        font-weight: bold;
        border-radius: 4px;
        padding: 0 4px;
      }

      .tag {
        color: #ff5370;
        font-weight: 700;
        text-shadow: 0 0 4px #ff3a58;
      }

      .attr {
        color: #82aaff;
        font-weight: 600;
        text-shadow: 0 0 5px #7199ff;
      }

      .value {
        color: #c3e88d;
        font-style: normal;
        font-weight: 600;
        text-shadow: 0 0 4px #a7d86b;
      }

      .punct {
        color: #f8f8f2;
        font-weight: 800;
      }

      /* Tooltip styles for character spans */
      .char-span {
        position: relative;
        cursor: help;
        white-space: pre; /* preserve spaces */
      }
      .char-span .tooltip {
        position: absolute;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        background-color: #222d48;
        color: #f0f0f0;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 0.85rem;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 10;
        max-width: 300px;
        word-break: normal;
      }
      .char-span:hover .tooltip,
      .char-span:focus .tooltip {
        opacity: 1;
        pointer-events: auto;
      }
      .char-span .tooltip::after {
        content: "";
        position: absolute;
        border-width: 6px;
        border-style: solid;
        border-color: #222d48 transparent transparent transparent;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
      }
      .preview-wrapper {
        width: 660px;
        padding: 0 24px;
        margin: 0 auto 50px;
        box-sizing: border-box;
      }

      #previewArea {
        border: 1.5px solid #ccc;
        background: #fff;
        border-radius: 12px;
        padding: 20px 24px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        font-family: "Segoe UI", sans-serif;
        font-size: 1rem;
        line-height: 1.7;
        color: #333;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <h1>InstaFont</h1>
    <div class="note">
      Disclaimer: This application only formats the appropriate font family per
      language and does not apply any styling such as padding, margin,
      positioning, color, bold, or italic, as it only accepts plain text. Future
      developments will be implemented.
    </div>

    <div class="font-size-container">
      <label for="fontSizeInput">Font size (pt):</label>
      <input
        type="number"
        id="fontSizeInput"
        min="10.5"
        max="15"
        value="10.5"
        step="0.1"
      />

      <label for="languageSelect">Language group:</label>
      <select id="languageSelect">
        <option value="'Segoe Pro'">Latin, Greek, Cyrillic</option>
        <option value="'Segoe UI'">Hebrew, Armenian, Georgian</option>
        <option value="'Segoe UI'">Arabic</option>
        <option value="'Nirmala UI'">Indian Languages</option>
        <option value="Leelawadee">Thai</option>
        <option value="Gadugi">Indigenous American</option>
        <option value="'Microsoft YaHei UI'">Chinese (Simplified)</option>
        <option value="'Microsoft JhengHei UI'">Chinese (Traditional)</option>
        <option value="'Malgun Gothic'">Korean</option>
        <option value="'Yu Gothic UI'" selected>Japanese</option>
        <option value="'Lao UI'">Lao</option>
      </select>
      <span class="note">Choose language for corresponding font style</span>
    </div>

    <label for="inputText">Enter your text below:</label>
    <textarea id="inputText" placeholder="Paste your text hereâ€¦"></textarea>

    <button onclick="formatText()">Format Text</button>
    <button id="btnCopy" onclick="copyOutput()">Copy Code</button>

    <div class="output-container">
      <div>
        <label for="output" class="output-label"
          >Formatted HTML Code Output</label
        >
        <pre id="output" readonly></pre>
      </div>
      <div>
        <label for="nonEnglishOutput" class="output-label"
          >Non-English Characters Highlighted</label
        >
        <pre id="nonEnglishOutput" readonly></pre>
      </div>
    </div>
    <div class="preview-wrapper">
      <label class="output-label">Preview Email</label>
      <div id="previewArea"></div>
    </div>

    <script>
      let rawFormattedHTML = "";

      function escapeHTML(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function syntaxHighlight(html) {
        let escaped = escapeHTML(html);

        escaped = escaped.replace(
          /(&lt;)(\/?)([\w-]+)([^&]*?)(&gt;)/g,
          (match, lt, slash, tagName, attrs, gt) => {
            let highlightedTag = `<span class="tag">${tagName}</span>`;
            let highlightedAttrs = attrs.replace(
              /([\w-]+)(=)(&quot;[^&]*?&quot;)/g,
              (m, attrName, eq, attrValue) =>
                `<span class="attr">${attrName}</span><span class="punct">${eq}</span><span class="value">${attrValue}</span>`
            );
            return `<span class="punct">${lt}</span>${slash}${highlightedTag}${highlightedAttrs}<span class="punct">${gt}</span>`;
          }
        );

        // Add visual newline before each <span> for better readability
        escaped = escaped.replace(/(&lt;span[^&]*?&gt;)/g, "\n$1");

        return escaped;
      }

      function highlightNonEnglishChars(text, selectedFont) {
        // For tooltip: English characters use 'Segoe UI', non-English use selectedFont
        // Get current font size from input
        const fontSizeInput = document.getElementById("fontSizeInput");
        const fontSize = fontSizeInput ? fontSizeInput.value.trim() : "10.5";

        // Split text into array of characters
        const chars = [...text];

        // Build HTML with spans and tooltips
        return chars
          .map((char) => {
            // Check for non-ASCII characters (generally non-English)
            const isNonEnglish = /[^\x00-\x7F]/.test(char);
            // Set font-family based on character type
            const fontFamily = isNonEnglish ? selectedFont : "'Segoe UI'";
            const highlightClass = isNonEnglish ? "highlight-nonenglish" : "";
            // Escape char for HTML, use non-breaking space for spaces
            const escapedChar = char === " " ? "\u00A0" : escapeHTML(char);

            // Tooltip content text
            const tooltipText = `Font: ${fontFamily.replace(
              /'/g,
              ""
            )}, Size: ${fontSize}pt`;

            // Apply font-family style directly to the span for the preview area
            return `<span class="char-span ${highlightClass}" tabindex="0" style="font-family:${fontFamily}">${escapedChar}<span class="tooltip">${tooltipText}</span></span>`;
          })
          .join("");
      }

      function formatText() {
        let inputText = document.getElementById("inputText").value;
        let fontSize = document.getElementById("fontSizeInput").value.trim();
        let languageSelect = document.getElementById("languageSelect");
        let selectedFont = languageSelect.value;
        let selectedText = languageSelect.selectedOptions[0].text;

        if (!inputText.trim()) {
          alert("Please enter some text to format.");
          return;
        }

        if (!fontSize || isNaN(fontSize) || fontSize <= 0) {
          alert("Please enter a valid positive font size.");
          return;
        }

        let formattedText = inputText;
        const isJapanese = selectedFont === "'Yu Gothic UI'";
        const isArabic = selectedText === "Arabic";

        if (isJapanese) {
          // 1. Insert spaces between Japanese characters and English/ASCII characters
          // Match: Japanese character followed by ASCII character (and no space between)
          formattedText = formattedText.replace(
            /([^\x00-\x7F\r\n\s])([A-Za-z0-9])/g,
            (match, jpChar, asciiChar) => `${jpChar} ${asciiChar}`
          );

          // Match: ASCII character followed by Japanese character (and no space between)
          formattedText = formattedText.replace(
            /([A-Za-z0-9])([^\x00-\x7F\r\n\s])/g,
            (match, asciiChar, jpChar) => `${asciiChar} ${jpChar}`
          );

          // 2. Wrap only ASCII/English chunks in an explicit Segoe UI span
          // Regex to split: ([^\x00-\x7F\r\n]+) catches non-ASCII (Japanese) runs and includes them in the array.
          // The remaining chunks are ASCII/English (including the newly added spaces)
          const splitByLanguage = formattedText.split(/([^\x00-\x7F\r\n]+)/g);

          formattedText = splitByLanguage
            .map((chunk) => {
              if (!chunk) return ""; // Skip empty strings from the split

              // Test if chunk is purely ASCII (English/Latin text, numbers, symbols, spaces, etc.)
              if (/^[\x00-\x7F\r\n]+$/.test(chunk)) {
                // This is an English chunk, wrap whole chunk in one span with Segoe UI
                return `<span style="font-family: 'Segoe UI', sans-serif;">${chunk}</span>`;
              } else {
                // Japanese or non-English chunk, return as is (it will inherit the Yu Gothic UI from the parent)
                return chunk;
              }
            })
            .join("");
        }

        // Convert remaining newlines to <br> tags. Using <br /> for maximum email compatibility.
        formattedText = formattedText.replace(/\n/g, "<br />");

        // Determine the outer wrapper tag and attributes
        let wrapperTag = isJapanese ? "div" : "p";
        let dirAttr = isArabic ? ' dir="rtl"' : "";
        let extraStyle = isArabic ? "text-align: right;" : "";

        // Construct the final HTML for the email
        // The parent element sets the default language font, and ASCII chunks override it.
        rawFormattedHTML = `<${wrapperTag} style="font-family:${selectedFont};font-size: ${fontSize}pt;${extraStyle}"${dirAttr}>${formattedText}</${wrapperTag}>`;

        // Display the highlighted HTML code
        document.getElementById("output").innerHTML =
          syntaxHighlight(rawFormattedHTML);

        // Display the non-English character preview
        document.getElementById("nonEnglishOutput").innerHTML =
          highlightNonEnglishChars(inputText, selectedFont);

        // Render to live preview
        document.getElementById("previewArea").innerHTML = rawFormattedHTML;
      }

      function copyOutput() {
        if (!rawFormattedHTML) {
          alert("No formatted code to copy. Please format your text first.");
          return;
        }

        // Insert newline before each <span> for better readability
        const formattedForCopy = rawFormattedHTML.replace(/<span/g, "\n<span");

        navigator.clipboard.writeText(formattedForCopy).then(
          () => {
            alert("Formatted HTML code copied to clipboard!");
          },
          () => {
            alert("Failed to copy. Please copy manually.");
          }
        );
      }
    </script>
  </body>
</html>
